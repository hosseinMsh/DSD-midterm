# گزارش پروژه: پیاده‌سازی ضرب‌کننده ۱۲۸ بیتی با روش Karatsuba در Verilog (ورودی ۸ بیتی)

## 🎯 هدف پروژه

در این پروژه، هدف طراحی یک مدار ضرب‌کننده برای اعداد صحیح علامت‌دار ۱۲۸ بیتی با استفاده از **روش Karatsuba** است. برای واحدهای ۶۴ بیتی داخلی از روش **Shift and Add** استفاده شده است.

به علت محدودیت‌های محیط Quartus (مثل تعداد محدودی از منابع FPGA و سختی نمایش مقادیر بزرگ در ابزار شبیه‌سازی)، ورودی‌ها و خروجی‌ها در سطح top به **۸ بیت** کاهش یافته‌اند، اما در هسته‌ی داخلی مدار، عملیات روی ۱۲۸ بیت انجام می‌شود.

---

## 🧱 ساختار کلی مدار

### ماژول `top.v`

ماژول سطح بالای پروژه است که دارای پورت‌های زیر است:

| پورت         | نوع   | توضیح                  |
| ------------ | ----- | ---------------------- |
| `a_in`       | 8 بیت | عدد اول ورودی (signed) |
| `b_in`       | 8 بیت | عدد دوم ورودی (signed) |
| `clk`        | 1 بیت | سیگنال ساعت            |
| `rst_n`      | 1 بیت | ریست فعال-پایین        |
| `result_out` | 8 بیت | ۸ بیت پایین حاصل ضرب   |

در این ماژول، ورودی‌های ۸ بیتی ابتدا به ۱۲۸ بیت sign-extended می‌شوند و سپس به ماژول Karatsuba ارسال می‌گردند.

```verilog
a <= {{120{a_in[7]}}, a_in};
b <= {{120{b_in[7]}}, b_in};
```

### ماژول `karatsuba_128.v`

این ماژول ضرب دو عدد ۱۲۸ بیتی را با استفاده از روش بازگشتی Karatsuba انجام می‌دهد. در اعماق بازگشت، ضرب ۶۴ بیتی توسط ماژول `shift_add_64.v` انجام می‌شود.

### ماژول `shift_add_64.v`

پیاده‌سازی ساده‌ی ضرب ۶۴ بیتی با استفاده از روش `Shift and Add`، که در هر سیکل کلاک یکی از بیت‌های ضرب شونده بررسی و به شرط فعال بودن، شیفت‌شده به حاصل جمع می‌شود.

### تست‌بنچ `tb_karatsuba.v`

تست‌بنچ ورودی‌های مختلفی را به مدار وارد می‌کند و خروجی را با مقدار صحیح بررسی می‌کند. در تست‌بنچ از عملگر `*` برای محاسبه پاسخ مرجع استفاده شده است (در Verilog برای شبیه‌سازی مجاز است).

---

## 🧪 تست و شبیه‌سازی

در فایل شبیه‌سازی (`.vwf`)، سیگنال‌های زیر بررسی شدند:

| `a_in` | `b_in` | `result_out`               |
| ------ | ------ | -------------------------- |
| 5      | -11    | -55                        |
| -2     | 32     | -64                        |
| 3      | 15     | 45                         |
| -8     | 12     | -96                        |
| 9      | 7      | 63                         |
| -7     | 1      | -7                         |
| 100    | 89     | 0 (overflow خارج از ۸ بیت) |

> در برخی موارد به علت محدودیت ۸ بیتی خروجی، overflow رخ می‌دهد و فقط ۸ بیت پایین قابل مشاهده است.

---

## ⚠️ محدودیت‌ها

* **خروجی ۸ بیت**: فقط ۸ بیت پایین نتیجه نمایش داده می‌شود. برای نتیجه‌ی کامل، باید خروجی تا 256 بیت توسعه یابد.
* **ورودی‌های ۸ بیت**: به دلیل محدودیت ابزار شبیه‌سازی و سخت‌افزار، ورودی‌ها به ۸ بیت کاهش یافته‌اند.
* **روش پیاده‌سازی**: به دلیل ممنوع بودن استفاده از عملگر `*` در طراحی اصلی، فقط در تست‌بنچ استفاده شده است.

---

## 🚀 راهنمای اجرا

### در Quartus:

1. پروژه را باز کنید و فایل `top.v` را به عنوان top-level entity تنظیم کنید.
2. فایل waveform (`.vwf`) را باز کرده و سیگنال‌ها را تنظیم کنید.
3. گزینه "Run Simulation" را انتخاب کنید.
4. خروجی `result_out` را بررسی کنید.

### در ModelSim یا Icarus Verilog:

اگر خواستید فایل‌های شبیه‌سازی CLI داشته باشید، می‌توانم یک `Makefile` یا دستور `iverilog + vvp` برایت بنویسم.

---

## 📂 فایل‌های پروژه

* `top.v` — ماژول سطح بالا با ورودی‌های ساده شده برای شبیه‌سازی
* `karatsuba_128.v` — پیاده‌سازی Karatsuba برای ۱۲۸ بیت
* `shift_add_64.v` — ضرب‌کننده ساده برای واحدهای ۶۴ بیتی
* `tb_karatsuba.v` — تست‌بنچ جهت تست صحت عملکرد مدار
* `so1.vwf` — فایل موج شبیه‌سازی در Quartus
